this is my WIP branch scratch pad, to be deleted before merging into master

Merge TODO list:
 * uncomment the commented out stage2 tests
 * remove the LazySrcLoc.todo tag
 * update astgen.zig
 * finish updating Sema.zig
 * finish implementing SrcLoc byteOffset function
 * audit all the .unneeded src locations
 * audit the calls in codegen toSrcLocWithDecl specifically if there is inlined function
   calls from other files.

Performance optimizations to look into:
 * don't store end index for blocks; rely on last instruction being noreturn
 * look into not storing the field name of field access as a string in zir
   instructions. or, look into introducing interning to string_bytes (local
   to the owner Decl), or, look into allowing field access based on a token/node
   and have it reference source code bytes. Another idea: null terminated
   string variants which avoid having to store the length.
   - Look into this for enum literals too
 * make ret_type and ret_ptr instructions be implied indexes; no need to have
   tags associated with them.
 * use a smaller encoding for the auto generated return void at the end of
   function ZIR.
 * enum literals can use small strings
 * string literals can use small strings
 * don't need the Sema coercion on condbr condition, it's done with result locations
 * astgen for loops using pointer arithmetic because it's faster and if the programmer
   wants an index capture, that will just be a convenience variable that zig sets up
   independently.
 * in astgen, if a decl_val would be to a const variable or to a function, there could be
   a special zir.Inst.Ref form that means to refer to a decl as the operand. This
   would elide all the decl_val instructions in the ZIR.
 * don't have an explicit dbg_stmt zir instruction - instead merge it with
   var decl and assignment instructions, etc.
   - make it set sema.src where appropriate
 * look into not emitting redundant dbg stmts to TZIR
 * make decl references in ZIR be u32 indexes to the Decl dependencies array hash map
   instead of duplicating *Decl entries in zir.Code.

                    if (maybe_src) |previous_src| {
                        return sema.mod.fail(&block.base, item.src, "duplicate switch value", .{});
                        // TODO notes "previous value is here" previous_src
                    }

                    const item = try sema.resolveInst(item_ref);
                    const value = try sema.resolveConstValue(block, item.src, item);
                    const maybe_src = try range_set.add(value, value, item.src);
                    try sema.validateSwitchDupeValue(parent_block, maybe_src, item.src);


                    const first = try sema.resolveInst(item_first);
                    const last = try sema.resolveInst(item_last);
                    const maybe_src = try range_set.add(
                            try sema.resolveConstValue(block, range_first_src, first_casted),
                            try sema.resolveConstValue(block, range_last_src, last_casted),
                            item.src,
                        );
                    };


                    const item = try sema.resolveInst(item_ref);
                    if ((try sema.resolveConstValue(block, item.src, item)).toBool()) {
                        true_count += 1;
                    } else {
                        false_count += 1;
                    }
                    if (true_count + false_count > 2) {
                        return sema.mod.fail(&block.base, item.src, "duplicate switch value", .{});
                    }



            for (inst.positionals.items) |item| {
                const resolved = try sema.resolveInst(item);
                const casted = try sema.coerce(block, operand.ty, resolved);
                const val = try sema.resolveConstValue(block, item_src, casted);

                if (try seen_values.fetchPut(val, item.src)) |prev| {
                    return sema.mod.fail(&block.base, item.src, "duplicate switch value", .{});
                    // TODO notes "previous value here" prev.value
                }
            }






fn switchCaseExpr(
    gz: *GenZir,
    scope: *Scope,
    rl: ResultLoc,
    block: *zir.Inst.Block,
    case: ast.full.SwitchCase,
    target: zir.Inst.Ref,
) !void {
    const tree = gz.tree();
    const node_datas = tree.nodes.items(.data);
    const main_tokens = tree.nodes.items(.main_token);
    const token_tags = tree.tokens.items(.tag);

    const case_src = token_starts[case.ast.arrow_token];
    const sub_scope = blk: {
        const payload_token = case.payload_token orelse break :blk scope;
        const ident = if (token_tags[payload_token] == .asterisk)
            payload_token + 1
        else
            payload_token;
        const is_ptr = ident != payload_token;
        const value_name = tree.tokenSlice(ident);
        if (mem.eql(u8, value_name, "_")) {
            if (is_ptr) {
                return mod.failTok(scope, payload_token, "pointer modifier invalid on discard", .{});
            }
            break :blk scope;
        }
        return mod.failTok(scope, ident, "TODO implement switch value payload", .{});
    };

    const case_body = try expr(gz, sub_scope, rl, case.ast.target_expr);
    if (!case_body.tag.isNoReturn()) {
        _ = try addZIRInst(mod, sub_scope, case_src, zir.Inst.Break, .{
            .block = block,
            .operand = case_body,
        }, .{});
    }
}
