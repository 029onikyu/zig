 * reimplement semaDecl
 * use a hash map for instructions because the array is too big

 * keep track of file dependencies/dependants
 * unload files from memory when a dependency is dropped

 * implement the new AstGen compile errors

 * get rid of failed_root_src_file
 * get rid of Scope.DeclRef
 * get rid of NameHash
 * handle decl collision with usingnamespace
 * the decl doing the looking up needs to create a decl dependency
   on each usingnamespace decl
 * handle usingnamespace cycles

 * compile error for return inside defer expression

 * when block has noreturn statement
   - avoid emitting defers
   - compile error for unreachable code
 
 * detect `return error.Foo` and emit ZIR that unconditionally generates errdefers
 * `return`: check return operand and generate errdefers if necessary

 * have failed_trees and just put the file in there
   - this way we can emit all the parse errors not just the first one
   - but maybe we want just the first one?

 * need a var decl zir instruction which includes the name because we need to do the
   compile error for a local shadowing a decl with Sema looking up the decl name.
   - this means LocalVal and LocalPtr should use the string table

 * sort compile errors before presenting them to eliminate nondeterministic error reporting

 * when handling decls, catch the error and continue, so that
   AstGen can report more than one compile error.

 * AstGen: add result location pointers to function calls
 * nested function decl: how to refer to params?

fn getAnonTypeName(mod: *Module, scope: *Scope, base_token: std.zig.ast.TokenIndex) ![]u8 {
    // TODO add namespaces, generic function signatrues
    const tree = scope.tree();
    const token_tags = tree.tokens.items(.tag);
    const base_name = switch (token_tags[base_token]) {
        .keyword_struct => "struct",
        .keyword_enum => "enum",
        .keyword_union => "union",
        .keyword_opaque => "opaque",
        else => unreachable,
    };
    const loc = tree.tokenLocation(0, base_token);
    return std.fmt.allocPrint(mod.gpa, "{s}:{d}:{d}", .{ base_name, loc.line, loc.column });
}


/// Returns `true` if the Decl type changed.
/// Returns `true` if this is the first time analyzing the Decl.
/// Returns `false` otherwise.
fn astgenAndSemaDecl(mod: *Module, decl: *Decl) !bool {
    const tracy = trace(@src());
    defer tracy.end();

    const tree = try mod.getAstTree(decl.namespace.file_scope);
    const node_tags = tree.nodes.items(.tag);
    const node_datas = tree.nodes.items(.data);
    const decl_node = decl.src_node;
    switch (node_tags[decl_node]) {
        .fn_decl => {
            const fn_proto = node_datas[decl_node].lhs;
            const body = node_datas[decl_node].rhs;
            switch (node_tags[fn_proto]) {
                .fn_proto_simple => {
                    var params: [1]ast.Node.Index = undefined;
                    return mod.astgenAndSemaFn(decl, tree.*, body, tree.fnProtoSimple(&params, fn_proto));
                },
                .fn_proto_multi => return mod.astgenAndSemaFn(decl, tree.*, body, tree.fnProtoMulti(fn_proto)),
                .fn_proto_one => {
                    var params: [1]ast.Node.Index = undefined;
                    return mod.astgenAndSemaFn(decl, tree.*, body, tree.fnProtoOne(&params, fn_proto));
                },
                .fn_proto => return mod.astgenAndSemaFn(decl, tree.*, body, tree.fnProto(fn_proto)),
                else => unreachable,
            }
        },
        .fn_proto_simple => {
            var params: [1]ast.Node.Index = undefined;
            return mod.astgenAndSemaFn(decl, tree.*, 0, tree.fnProtoSimple(&params, decl_node));
        },
        .fn_proto_multi => return mod.astgenAndSemaFn(decl, tree.*, 0, tree.fnProtoMulti(decl_node)),
        .fn_proto_one => {
            var params: [1]ast.Node.Index = undefined;
            return mod.astgenAndSemaFn(decl, tree.*, 0, tree.fnProtoOne(&params, decl_node));
        },
        .fn_proto => return mod.astgenAndSemaFn(decl, tree.*, 0, tree.fnProto(decl_node)),

        .global_var_decl => return mod.astgenAndSemaVarDecl(decl, tree.*, tree.globalVarDecl(decl_node)),
        .local_var_decl => return mod.astgenAndSemaVarDecl(decl, tree.*, tree.localVarDecl(decl_node)),
        .simple_var_decl => return mod.astgenAndSemaVarDecl(decl, tree.*, tree.simpleVarDecl(decl_node)),
        .aligned_var_decl => return mod.astgenAndSemaVarDecl(decl, tree.*, tree.alignedVarDecl(decl_node)),

        .@"comptime" => {
            decl.analysis = .in_progress;

            // A comptime decl does not store any value so we can just deinit this arena after analysis is done.
            var analysis_arena = std.heap.ArenaAllocator.init(mod.gpa);
            defer analysis_arena.deinit();

            var sema: Sema = .{
                .mod = mod,
                .gpa = mod.gpa,
                .arena = &analysis_arena.allocator,
                .code = code,
                .inst_map = try analysis_arena.allocator.alloc(*ir.Inst, code.instructions.len),
                .owner_decl = decl,
                .namespace = decl.namespace,
                .func = null,
                .owner_func = null,
                .param_inst_list = &.{},
            };
            var block_scope: Scope.Block = .{
                .parent = null,
                .sema = &sema,
                .src_decl = decl,
                .instructions = .{},
                .inlining = null,
                .is_comptime = true,
            };
            defer block_scope.instructions.deinit(mod.gpa);

            _ = try sema.root(&block_scope);

            decl.analysis = .complete;
            decl.generation = mod.generation;
            return true;
        },
        .@"usingnamespace" => {
            decl.analysis = .in_progress;

            var code: Zir = blk: {
                var astgen = try AstGen.init(mod, decl, &analysis_arena.allocator);
                defer astgen.deinit();

                var gen_scope: Scope.GenZir = .{
                    .force_comptime = true,
                    .parent = &decl.namespace.base,
                    .astgen = &astgen,
                };
                defer gen_scope.instructions.deinit(mod.gpa);

                const ns_type = try AstGen.typeExpr(&gen_scope, &gen_scope.base, type_expr);

            };
            try decl.namespace.usingnamespace_set.put(mod.gpa, ty.getNamespace().?, is_pub);

            decl.analysis = .complete;
            decl.generation = mod.generation;
            return true;
        },
        else => unreachable,
    }
}

fn astgenAndSemaFn(
    mod: *Module,
    decl: *Decl,
    tree: ast.Tree,
    body_node: ast.Node.Index,
    fn_proto: ast.full.FnProto,
) !bool {
    const is_inline = fn_type.fnCallingConvention() == .Inline;
    const anal_state: Fn.Analysis = if (is_inline) .inline_only else .queued;

    new_func.* = .{
        .state = anal_state,
        .zir = fn_zir,
        .body = undefined,
        .owner_decl = decl,
    };
    fn_payload.* = .{
        .base = .{ .tag = .function },
        .data = new_func,
    };

    var prev_type_has_bits = false;
    var prev_is_inline = false;
    var type_changed = true;

    if (decl.typedValueManaged()) |tvm| {
        prev_type_has_bits = tvm.typed_value.ty.hasCodeGenBits();
        type_changed = !tvm.typed_value.ty.eql(fn_type);
        if (tvm.typed_value.val.castTag(.function)) |payload| {
            const prev_func = payload.data;
            prev_is_inline = prev_func.state == .inline_only;
            prev_func.deinit(mod.gpa);
        }

        tvm.deinit(mod.gpa);
    }

    decl_arena_state.* = decl_arena.state;
    decl.typed_value = .{
        .most_recent = .{
            .typed_value = .{
                .ty = fn_type,
                .val = Value.initPayload(&fn_payload.base),
            },
            .arena = decl_arena_state,
        },
    };
    decl.analysis = .complete;
    decl.generation = mod.generation;

    if (!is_inline and fn_type.hasCodeGenBits()) {
        // We don't fully codegen the decl until later, but we do need to reserve a global
        // offset table index for it. This allows us to codegen decls out of dependency order,
        // increasing how many computations can be done in parallel.
        try mod.comp.bin_file.allocateDeclIndexes(decl);
        try mod.comp.work_queue.writeItem(.{ .codegen_decl = decl });
        if (type_changed and mod.emit_h != null) {
            try mod.comp.work_queue.writeItem(.{ .emit_h_decl = decl });
        }
    } else if (!prev_is_inline and prev_type_has_bits) {
        mod.comp.bin_file.freeDecl(decl);
    }

    if (fn_proto.extern_export_token) |maybe_export_token| {
        if (token_tags[maybe_export_token] == .keyword_export) {
            if (is_inline) {
                return mod.failTok(
                    &block_scope.base,
                    maybe_export_token,
                    "export of inline function",
                    .{},
                );
            }
            const export_src = decl.tokSrcLoc(maybe_export_token);
            const name = tree.tokenSlice(fn_proto.name_token.?); // TODO identifierTokenString
            // The scope needs to have the decl in it.
            try mod.analyzeExport(&block_scope.base, export_src, name, decl);
        }
    }
    return type_changed or is_inline != prev_is_inline;
}
        log.debug("extern fn symbol expected in lib '{s}'", .{lib_name_str});
        mod.comp.stage1AddLinkLib(lib_name_str) catch |err| {
            return mod.failTok(
                &fn_type_scope.base,
                lib_name_token,
                "unable to add link lib '{s}': {s}",
                .{ lib_name_str, @errorName(err) },
            );
        };
        const target = mod.comp.getTarget();
        if (target_util.is_libc_lib_name(target, lib_name_str)) {
            if (!mod.comp.bin_file.options.link_libc) {
                return mod.failTok(
                    &fn_type_scope.base,
                    lib_name_token,
                    "dependency on libc must be explicitly specified in the build command",
                    .{},
                );
            }
            break :blk;
        }
        if (target_util.is_libcpp_lib_name(target, lib_name_str)) {
            if (!mod.comp.bin_file.options.link_libcpp) {
                return mod.failTok(
                    &fn_type_scope.base,
                    lib_name_token,
                    "dependency on libc++ must be explicitly specified in the build command",
                    .{},
                );
            }
            break :blk;
        }
        if (!target.isWasm() and !mod.comp.bin_file.options.pic) {
            return mod.failTok(
                &fn_type_scope.base,
                lib_name_token,
                "dependency on dynamic library '{s}' requires enabling Position Independent Code. Fixed by `-l{s}` or `-fPIC`.",
                .{ lib_name_str, lib_name_str },
            );
        }

    if (mod.lookupIdentifier(scope, ident_name)) |decl| {
        const msg = msg: {
            const msg = try mod.errMsg(
                scope,
                name_src,
                "redeclaration of '{s}'",
                .{ident_name},
            );
            errdefer msg.destroy(gpa);
            try mod.errNoteNonLazy(decl.srcLoc(), msg, "previously declared here", .{});
            break :msg msg;
        };
        return mod.failWithOwnedErrorMsg(scope, msg);
    }


    var type_changed = true;
    if (decl.typedValueManaged()) |tvm| {
        type_changed = !tvm.typed_value.ty.eql(var_info.ty);

        tvm.deinit(mod.gpa);
    }

    const new_variable = try decl_arena.allocator.create(Var);
    new_variable.* = .{
        .owner_decl = decl,
        .init = var_info.val orelse undefined,
        .is_extern = is_extern,
        .is_mutable = is_mutable,
        .is_threadlocal = is_threadlocal,
    };
    const var_val = try Value.Tag.variable.create(&decl_arena.allocator, new_variable);

    decl_arena_state.* = decl_arena.state;
    decl.typed_value = .{
        .most_recent = .{
            .typed_value = .{
                .ty = var_info.ty,
                .val = var_val,
            },
            .arena = decl_arena_state,
        },
    };
    decl.analysis = .complete;
    decl.generation = mod.generation;



    if (is_mutable and !var_info.ty.isValidVarType(is_extern)) {
        return mod.failTok(
            &decl_scope.base,
            var_decl.ast.mut_token,
            "variable of type '{}' must be const",
            .{var_info.ty},
        );
    }

    if (var_decl.extern_export_token) |maybe_export_token| {
        if (token_tags[maybe_export_token] == .keyword_export) {
            const export_src = decl.tokSrcLoc(maybe_export_token);
            const name_token = var_decl.ast.mut_token + 1;
            const name = tree.tokenSlice(name_token); // TODO identifierTokenString
            // The scope needs to have the decl in it.
            try mod.analyzeExport(&decl_scope.base, export_src, name, decl);
        }
    }


    const error_set = try arena.create(Module.ErrorSet);
    error_set.* = .{
        .owner_decl = astgen.decl,
        .node_offset = astgen.decl.nodeIndexToRelative(node),
        .names_ptr = fields.ptr,
        .names_len = @intCast(u32, fields.len),
    };
    const error_set_ty = try Type.Tag.error_set.create(arena, error_set);
    const error_set_val = try Value.Tag.ty.create(arena, error_set_ty);
    const new_decl = try mod.createAnonymousDecl(scope, &new_decl_arena, .{
        .ty = Type.initTag(.type),
        .val = error_set_val,
    });
    const decl_index = try mod.declareDeclDependency(astgen.decl, new_decl);
    const result = try gz.addDecl(.decl_val, decl_index, node);
    return rvalue(gz, scope, rl, result, node);



        // when implementing this be sure to add test coverage for the asm return type
        // not resolving into a type (the node_offset_asm_ret_ty  field of LazySrcLoc)



pub fn analyzeNamespace(
    mod: *Module,
    namespace: *Scope.Namespace,
    decls: []const ast.Node.Index,
) InnerError!void {
    for (decls) |decl_node| switch (node_tags[decl_node]) {
        .@"comptime" => {
            const name_index = mod.getNextAnonNameIndex();
            const name = try std.fmt.allocPrint(mod.gpa, "__comptime_{d}", .{name_index});
            defer mod.gpa.free(name);

            const contents_hash = std.zig.hashSrc(tree.getNodeSource(decl_node));

            const new_decl = try mod.createNewDecl(namespace, name, decl_node, name_hash, contents_hash);
            namespace.decls.putAssumeCapacity(new_decl, {});
            mod.comp.work_queue.writeItemAssumeCapacity(.{ .analyze_decl = new_decl });
        },

        // Container fields are handled in AstGen.
        .container_field_init,
        .container_field_align,
        .container_field,
        => continue,

        .test_decl => {
            if (mod.comp.bin_file.options.is_test) {
                log.err("TODO: analyze test decl", .{});
            }
        },
        .@"usingnamespace" => {
            const name_index = mod.getNextAnonNameIndex();
            const name = try std.fmt.allocPrint(mod.gpa, "__usingnamespace_{d}", .{name_index});
            defer mod.gpa.free(name);

            const contents_hash = std.zig.hashSrc(tree.getNodeSource(decl_node));

            const new_decl = try mod.createNewDecl(namespace, name, decl_node, name_hash, contents_hash);
            namespace.decls.putAssumeCapacity(new_decl, {});

            mod.ensureDeclAnalyzed(new_decl) catch |err| switch (err) {
                error.OutOfMemory => return error.OutOfMemory,
                error.AnalysisFail => continue,
            };
        },
        else => unreachable,
    };
}

