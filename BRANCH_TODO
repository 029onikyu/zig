 * zig fmt support for the syntax
 * alignment of variables not being respected in async functions
 * await of a non async function
 * async call on a non async function
 * documentation
   - @asyncCall
   - @frame
   - @Frame
   - @frameSize
   - coroutines section
   - suspend
   - resume
   - anyframe, anyframe->T
 * a test where an async function destroys its own frame in a defer
 * compile error (instead of crashing) for trying to get @Frame of generic function
 * compile error (instead of crashing) for trying to async call and passing @Frame of wrong function
 * implicit cast of normal function to async function should be allowed when it is inferred to be async
 * compile error for error: expected anyframe->T, found 'anyframe'
 * compile error for error: expected anyframe->T, found 'i32'
 * peer type resolution of *@Frame(func) and anyframe
 * peer type resolution of *@Frame(func) and anyframe->T when the return type matches
 * for loops need to spill the index. other payload captures probably also need to spill
 * `const result = (await a) + (await b);` this causes "Instruction does not dominate all uses" - need spill
 * @typeInfo for @Frame(func)
 * returning a value from within a suspend block
 * make resuming inside a suspend block, with nothing after it, a must-tail call.
 * make sure there are safety tests for all the new safety features (search the new PanicFnId enum values)
 * compile error for casting a function to a non-async function pointer, but then later it gets inferred to be an async function
 * compile error for copying a frame
 * compile error for resuming a const frame pointer
 * runtime safety enabling/disabling scope has to be coordinated across resume/await/calls/return
 * calling a generic function which is async
 * make sure `await @asyncCall` and `await async` are handled correctly.
 * allow @asyncCall with a real @Frame(func) (the point of this is result pointer)
 * when there are multiple calls to async functions in a function, reuse the same frame buffer, so that the
   needed bytes is equal to the largest callee's frame 
 * if an async function is never called with async then a few optimizations can be made:
   - the return does not need to be atomic
   - it can be assumed that these are always available: the awaiter ptr, return ptr if applicable,
     error return trace ptr if applicable.
   - it can be assumed that it is never cancelled
 * fix the debug info for variables of async functions
