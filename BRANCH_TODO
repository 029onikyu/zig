 * AstGen threadlocal
 * extern "foo" for vars and for functions
 * namespace decls table can't reference ZIR memory because it can get modified on updates
   - change it for astgen worker to compare old and new ZIR, updating existing
     namespaces & decls, and creating a changelist.
 * reimplement semaDecl
 * use a hash map for instructions because the array is too big
   - no, actually modify the Zir.Inst.Ref strategy so that each decl gets
     their indexes starting at 0 so that we can use an array to store Sema
     results rather than a map.

 * keep track of file dependencies/dependants
 * unload files from memory when a dependency is dropped

 * implement the new AstGen compile errors

 * get rid of failed_root_src_file
 * get rid of Scope.DeclRef
 * get rid of NameHash
 * handle decl collision with usingnamespace
 * the decl doing the looking up needs to create a decl dependency
   on each usingnamespace decl
 * handle usingnamespace cycles

 * compile error for return inside defer expression

 * when block has noreturn statement
   - avoid emitting defers
   - compile error for unreachable code
 
 * detect `return error.Foo` and emit ZIR that unconditionally generates errdefers
 * `return`: check return operand and generate errdefers if necessary

 * have failed_trees and just put the file in there
   - this way we can emit all the parse errors not just the first one
   - but maybe we want just the first one?

 * need a var decl zir instruction which includes the name because we need to do the
   compile error for a local shadowing a decl with Sema looking up the decl name.
   - this means LocalVal and LocalPtr should use the string table

 * sort compile errors before presenting them to eliminate nondeterministic error reporting

 * when handling decls, catch the error and continue, so that
   AstGen can report more than one compile error.

 * AstGen: add result location pointers to function calls
 * nested function decl: how to refer to params?

 * fix the commented out behavior test regarding function alignment
   - not sure why this happened, it's stage1 code??
   - search the behavior test diff for "TODO"

 * memory efficiency: add another representation for structs which use
   natural alignment for fields and do not have any comptime fields. this
   will save 16 bytes per struct field in the compilation.


